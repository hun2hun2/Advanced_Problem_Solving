e0:
e801

print(*answers)		# print final states

e800:
if input != []:		# synthesize programs that perform on some input (or initial state), as done by most programs
    answers = []		# initialize output states
    e1			# perform actions to transition to desired final states

e801:
e800			# single line of actions
----
e800			# two lines of actions
input = answers
e800			# replacing e800 with e801 means 'two or more lines of actions'

e1:
answers.append( e2 )	# single output
----
e3	# multiple outputs

e2:	# single output
e21	# output = one element among inputs
----
e22	# output = f(inputs), e.g., add even #s

e21:	# output = one element among inputs
max(input)
----
min(input)

e22:	# output = f(inputs)
sum( e221 for i in input if e300 )	# add or count all items that meet condition
----
any( e300 for i in input )	# determine if any item meets condition (True or False)

e221:
i		# sum all inputs that meet specified condition
----
1		# count # of times event occurred


e3:	# multiple outputs
answers = [ e321 for i in input if e300 ]
----
answers = sorted(input, reverse= e700 )

e321:	# what to store
i
----
abs(i)
----
-i
----
i + e502

e300:	# condition
True
----
e101 e102 e501

e101:
i		# use input as it is
----
i % e502	# modify input before conditioning

e102:
>
----
==
----
<

e501:	# constants that are frequently used (include 0)
0
----
e502

e502:	# constants that are frequently used (exclude 0)
2
----
3

e700:	# True or False
True
----
False